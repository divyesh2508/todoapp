/*
 * sonar-scanner-npm
 * Copyright (C) 2022-2024 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runScannerCli = exports.downloadScannerCli = exports.normalizePlatformName = void 0;

const child_process_1 = require("child_process");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const file_1 = require("./file");
const logging_1 = require("./logging");
const platform_1 = require("./platform");
const proxy_1 = require("./proxy");
const request_1 = require("./request");
const types_1 = require("./types");
function normalizePlatformName() {
    if ((0, platform_1.isWindows)()) {
        return 'windows';
    }
    if ((0, platform_1.isLinux)()) {
        return 'linux';
    }
    if ((0, platform_1.isMac)()) {
        return 'macosx';
    }
    throw Error(`Your platform '${process.platform}' is currently not supported.`);
}
exports.normalizePlatformName = normalizePlatformName;
/**
 * Where to download the SonarScanner CLI
 */
function getScannerCliUrl(properties, version) {
    // Get location to download scanner-cli from
    // Not in default to avoid populating it for non scanner-cli users
    const scannerCliMirror = properties[types_1.ScannerProperty.SonarScannerCliMirror] ?? constants_1.SCANNER_CLI_MIRROR;
    const scannerCliFileName = 'sonar-scanner-cli-' + version + '-' + normalizePlatformName() + '.zip';
    return new URL(scannerCliFileName, scannerCliMirror);
}
async function downloadScannerCli(properties) {
    const version = properties[types_1.ScannerProperty.SonarScannerCliVersion] ?? constants_1.SCANNER_CLI_VERSION;
    if (!/^[\d.]+$/.test(version)) {
        throw new Error(`Version "${version}" does not have a correct format."`);
    }
    // Build paths
    const binExt = normalizePlatformName() === 'windows' ? '.bat' : '';
    const dirName = `sonar-scanner-${version}-${normalizePlatformName()}`;
    const installDir = path_1.default.join(properties[types_1.ScannerProperty.SonarUserHome], constants_1.SCANNER_CLI_INSTALL_PATH);
    const archivePath = path_1.default.join(installDir, `${dirName}.zip`);
    const binPath = path_1.default.join(installDir, dirName, 'bin', `sonar-scanner${binExt}`);
    if (await fs_extra_1.default.exists(binPath)) {
        return binPath;
    }
    // Create parent directory if needed
    await fs_extra_1.default.ensureDir(installDir);
    // Add basic auth credentials when used in the UR
    const scannerCliUrl = getScannerCliUrl(properties, version);
    let overrides;
    if (scannerCliUrl.username && scannerCliUrl.password) {
        overrides = {
            headers: {
                Authorization: 'Basic ' +
                    Buffer.from(`${scannerCliUrl.username}:${scannerCliUrl.password}`).toString('base64'),
            },
        };
    }
    // Download SonarScanner CLI
    (0, logging_1.log)(logging_1.LogLevel.INFO, 'Downloading SonarScanner CLI');
    (0, logging_1.log)(logging_1.LogLevel.DEBUG, `Downloading from ${scannerCliUrl.href}`);
    await (0, request_1.download)(scannerCliUrl.href, archivePath, overrides);
    (0, logging_1.log)(logging_1.LogLevel.INFO, `Extracting SonarScanner CLI archive`);
    await (0, file_1.extractArchive)(archivePath, installDir);
    return binPath;
}
exports.downloadScannerCli = downloadScannerCli;
/**
 * @param binPath Absolute path to the scanner CLI executable
 */
async function runScannerCli(scanOptions, properties, binPath) {
    (0, logging_1.log)(logging_1.LogLevel.INFO, 'Starting analysis');
    // We filter out env properties that are passed to the scanner
    // otherwise, they would supersede the properties passed to the scanner through SONARQUBE_SCANNER_PARAMS
    const filteredEnvKeys = constants_1.ENV_TO_PROPERTY_NAME.map(env => env[0]);
    const filteredEnv = Object.entries(process.env)
        .filter(([key]) => !filteredEnvKeys.includes(key))
        .filter(([key]) => !key.startsWith(constants_1.ENV_VAR_PREFIX));
    const child = (0, child_process_1.spawn)(binPath, [...(scanOptions.jvmOptions ?? []), ...(0, proxy_1.proxyUrlToJavaOptions)(properties)], {
        env: {
            ...Object.fromEntries(filteredEnv),
            SONARQUBE_SCANNER_PARAMS: JSON.stringify(properties),
        },
        shell: (0, platform_1.isWindows)(),
    });
    child.stdout.on('data', buffer => process.stdout.write(buffer));
    child.stderr.on('data', buffer => (0, logging_1.log)(logging_1.LogLevel.ERROR, buffer.toString()));
    return new Promise((resolve, reject) => {
        child.on('exit', code => {
            if (code === 0) {
                (0, logging_1.log)(logging_1.LogLevel.INFO, 'SonarScanner CLI finished successfully');
                resolve();
            }
            else {
                reject(new Error(`SonarScanner CLI failed with code ${code}`));
            }
        });
    });
}
exports.runScannerCli = runScannerCli;
